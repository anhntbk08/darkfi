<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Template syntax (and expansion options) reference"><title>derive_adhoc::doc_reference - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="derive_adhoc" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0-nightly (0bdb00d55 2023-08-15)" data-channel="nightly" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../derive_adhoc/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../derive_adhoc/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module doc_reference</a></h2><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">derive_adhoc</a>::<wbr><a class="mod" href="#">doc_reference</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/derive_adhoc/lib.rs.html#26">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="template-syntax-and-expansion-options-reference"><a href="#template-syntax-and-expansion-options-reference"><strong>Template syntax (and expansion options) reference</strong></a></h2>
<p><strong>Table of contents</strong></p>
<!--##toc##-->
<ul>
<li><a href="#template-syntax-overview">Template syntax overview</a>
<ul>
<li><a href="#named-and-positional-template-arguments-to-expansions-and-conditions">Named and positional template arguments to expansions and conditions</a></li>
</ul>
</li>
<li><a href="#repetition-and-nesting">Repetition and nesting</a></li>
<li><a href="#expansions">Expansions</a>
<ul>
<li><a href="#fname-vname-tname--names"><code>$fname</code>, <code>$vname</code>, <code>$tname</code> – names</a></li>
<li><a href="#fvis-tvis-fdefvis--visibility"><code>$fvis</code>, <code>$tvis</code>, <code>$fdefvis</code> – visibility</a></li>
<li><a href="#vpat-fpatname--pattern-matching-and-value-deconstruction"><code>$vpat</code>, <code>$fpatname</code> – pattern matching and value deconstruction</a></li>
<li><a href="#ftype-vtype-ttype-tdeftype--types"><code>$ftype</code>, <code>$vtype</code>, <code>$ttype</code>, <code>$tdeftype</code> – types</a></li>
<li><a href="#tgens-tgnames-twheres-tdefgens--generics"><code>$tgens</code>, <code>$tgnames</code>, <code>$twheres</code>, <code>$tdefgens</code> – generics</a></li>
<li><a href="#tmeta-vmeta-fmeta--adhoc-attributes"><code>${tmeta(...)}</code> <code>${vmeta(...)}</code> <code>${fmeta(...)}</code> – <code>#[adhoc]</code> attributes</a></li>
<li><a href="#fattrs--vattrs--tattrs---other-attributes"><code>${fattrs ...}</code> <code>${vattrs ...}</code> <code>${tattrs ...}</code> – other attributes</a></li>
<li><a href="#-paste---identifier-pasting"><code>$&lt;...&gt;</code>, <code>${paste ...}</code> – identifier pasting</a></li>
<li><a href="#case_change---case-changing"><code>${CASE_CHANGE ...}</code> – case changing</a></li>
<li><a href="#when-condition--filtering-out-repetitions-by-a-predicate"><code>${when CONDITION}</code> – filtering out repetitions by a predicate</a></li>
<li><a href="#if-cond1----else-if-cond2----else-----conditional"><code>${if COND1 { ... } else if COND2 { ... } else { ... }}</code> – conditional</a></li>
<li><a href="#select1-cond1----else-if-cond2----else-----expect-precisely-one-predicate"><code>${select1 COND1 { ... } else if COND2 { ... } else { ... }}</code> – expect precisely one predicate</a></li>
<li><a href="#for-fields----for-variants-------repetition"><code>${for fields { ... }}</code>, <code>${for variants { ... }}</code>, <code>$( )</code> – repetition</a></li>
<li><a href="#crate--root-of-template-crate"><code>$crate</code> – root of template crate</a></li>
<li><a href="#tdefkwd--keyword-introducing-the-new-data-structure"><code>$tdefkwd</code> – keyword introducing the new data structure</a></li>
<li><a href="#tdefvariants-vdefbody-fdefine--tools-for-defining-types"><code>$tdefvariants</code>, <code>$vdefbody</code>, <code>$fdefine</code> – tools for defining types</a></li>
<li><a href="#dbg_all_keywords--dump-expansions-of-all-keywords-to-compiler-stderr"><code>$dbg_all_keywords</code> – Dump expansions of all keywords to compiler stderr</a></li>
<li><a href="#define--defcond---user-defined-expansions-and-conditions"><code>${define ...}</code>, <code>${defcond ...}</code> – user-defined expansions and conditions</a></li>
</ul>
</li>
<li><a href="#conditions">Conditions</a>
<ul>
<li><a href="#fvis-tvis-fdefvis--test-for-public-visibility"><code>fvis</code>, <code>tvis</code>, <code>fdefvis</code> – test for public visibility</a></li>
<li><a href="#fmetaname-vmetaname-tmetaname--adhoc-attributes"><code>fmeta(NAME)</code>, <code>vmeta(NAME)</code>, <code>tmeta(NAME)</code> – <code>#[adhoc]</code> attributes</a></li>
<li><a href="#is_struct-is_enum-is_union"><code>is_struct</code>, <code>is_enum</code>, <code>is_union</code></a></li>
<li><a href="#v_is_unit-v_is_tuple-v_is_named"><code>v_is_unit</code>, <code>v_is_tuple</code>, <code>v_is_named</code></a></li>
<li><a href="#approx_equalarg1-arg2--equality-comparison-token-comparison"><code>approx_equal(ARG1, ARG2)</code> – equality comparison (token comparison)</a></li>
<li><a href="#false-true-notcondition-anycond1cond2-allcond1cond2--boolean-logic"><code>false</code>, <code>true</code>, <code>not(CONDITION)</code>, <code>any(COND1,COND2,...)</code>, <code>all(COND1,COND2,...)</code> – boolean logic</a></li>
</ul>
</li>
<li><a href="#case-changing">Case changing</a></li>
<li><a href="#expansion-options">Expansion options</a>
<ul>
<li><a href="#expect-items-expect-expr--syntax-check-the-expansion"><code>expect items</code>, <code>expect expr</code> – syntax check the expansion</a></li>
<li><a href="#for-struct-for-enum-for-union--insist-on-a-particular-driver-kind"><code>for struct</code>, <code>for enum</code>, <code>for union</code> – Insist on a particular driver kind</a></li>
<li><a href="#dbg--print-the-expansion-to-stderr-for-debugging"><code>dbg</code> – Print the expansion to stderr, for debugging</a></li>
<li><a href="#expansion-options-example">Expansion options example</a></li>
</ul>
</li>
<li><a href="#structs-used-in-examples">Structs used in examples</a></li>
</ul>
<p><strong>Reference documentation for the actual proc macros</strong> is in
the <a href="../index.html#macros">crate-level docs for derive-adhoc</a>.</p>
<h3 id="template-syntax-overview"><a href="#template-syntax-overview">Template syntax overview</a></h3>
<p>Within the macro template,
expansions (and control structures) are introduced with <code>$</code>.
They generally refer to properties of the data structure that
we’re deriving from.
We call that data structure the <strong>driver</strong>.</p>
<p>In general the syntax is:</p>
<ul>
<li><code>$KEYWORD</code>: Invoke the expansion of the keyword <code>KEYWORD</code>.</li>
<li><code>${KEYWORD ARGS...}</code>: Invoke with parameters.</li>
<li><code>$( .... )</code>: Repetition (abbreviated, automatic, form).
(Note: there is no <code>+</code> or <code>*</code> after the <code>)</code>)</li>
<li><code>$&lt; .... &gt;</code>: Identifier pasting (shorthand for
<a href="#-paste---identifier-pasting"><code>${paste ...}</code></a>).</li>
</ul>
<p>In all cases, <code>$KEYWORD</code> is equivalent to <code>${KEYWORD}</code>.
You can pass a <code>$</code> through
(e.g. if you want to confuse yourself
by making derive-adhoc-generated pattern macros)
by writing <code>$$</code>.</p>
<p>Many of the expansion keywords start with <code>f</code>, <code>v</code>, or <code>s</code> to indicate
the depth of the thing being expanded:</p>
<ul>
<li>
<p><code>f...</code>: Expand something belonging to a particular Field.</p>
</li>
<li>
<p><code>v...</code>: Expand something belonging to a particular Variant.</p>
</li>
<li>
<p><code>t...</code>: Expand something applying to the whole Top-level type.</p>
</li>
</ul>
<p>In the keyword descriptions below,
<code>X</code> is used to stand in for one of <code>f</code>, <code>v</code> or <code>t</code>.</p>
<p>Defining a new type based on the driver
requires more complex and subtle syntax,
generated by special-purpose expansions <code>$Xdef...</code>.</p>
<p>(Here, within this documentation,
we often write in <code>CAPITALS</code> to indicate meta-meta-syntactic elements,
since all of the punctuation is already taken.)</p>
<p>Inner attributes (<code>#![...]</code> and <code>//!...</code>)
are not allowed in templates.</p>
<h4 id="named-and-positional-template-arguments-to-expansions-and-conditions"><a href="#named-and-positional-template-arguments-to-expansions-and-conditions">Named and positional template arguments to expansions and conditions</a></h4>
<p>Some expansions and conditions take
(possibly optional)
named arguments,
or multiple positional arguments,
whose values are templates:</p>
<ul>
<li><code>${KEYWORD NAME=ARG NAME=ARG ...}</code></li>
<li><code>${KEYWORD ARG1 ARG2 ...}</code></li>
<li><code>CONDITION(NAME=ARG, NAME=ARG, ...)</code></li>
<li><code>CONDITION(ARG1, ARG2, ...)</code></li>
</ul>
<p>The acceptable contents vary,
but the syntax is always the same.
Each <code>ARG</code> must be one of:</p>
<ul>
<li><code>IDENTIFIER</code></li>
<li><code>LITERAL</code> (eg, <code>NUMBER</code> or <code>&quot;STRING&quot;</code>)</li>
<li><code>$EXPANSION</code> or <code>${EXPANSION}</code> or <code>${EXPANSION...}</code> or <code>$&lt;...&gt;</code></li>
<li><code>{ STUFF }</code>, where <code>STUFF</code> is expanded.
(The <code>{ }</code> just for delimiting the value, and are discarded).</li>
</ul>
<h3 id="repetition-and-nesting"><a href="#repetition-and-nesting">Repetition and nesting</a></h3>
<p>The driving data structure can contain multiple variants,
which can in turn contain multiple fields;
there are also attributes.</p>
<p>Correspondingly,
sections of the template, indicated by <code>${for ...}</code> and <code>$( ...)</code>,
are expanded multiple times.</p>
<p>With <code>${for ...}</code>, what is iterated over is specified explicitly.</p>
<p>When <code>$( ... )</code> is used, what is iterated over is automatically
inferred from the content:
most expansions and conditions imply a “level”:
what possibly-repeated part of the driver they correspond to.
All the expansions directly within <code>$(...)</code>
must have the same repetition level.</p>
<p>With both <code>${for }</code> and <code>$( ... )</code>,
if the repetition level is “deeper” than the level
of the surrounding template,
the surrounding levels are also repeated over,
effectively “flattening”.
For example, expanding <code>$( $fname )</code> at the very toplevel,
will iterate over all of the field names;
if the driver is an enum;
it will iterate over all of the fields in each of the variants
in turn.</p>
<p>structs and unions do not have variants, but
derive-adhoc treats them as having a single (unnamed) variant.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5><!--##examples-for `Enum`##-->
<!--##examples-ignore##-->
<p>For <a href="#structs-used-in-examples">example enum <code>Enum</code></a>:</p>
<ul>
<li><code>$($vname,)</code>: <code>UnitVariant, TupleVariant, NamedVariant,</code></li>
<li><code>$($fname)</code>: <code>0 field field_b field_e</code></li>
<li><code>${for fields { hello }}</code>: <code>hello hello hello hello</code></li>
</ul>
<h3 id="expansions"><a href="#expansions">Expansions</a></h3>
<p>Each expansion keyword is described in this section.
The examples each show the expansions for (elements of)
the same example <code>Unit</code>, <code>Tuple</code>, <code>Struct</code> and <code>Enum</code>,
shown below.</p>
<!-- ## maint/check-keywords-documented expansions ## -->
<h4 id="fname-vname-tname--names"><a href="#fname-vname-tname--names"><code>$fname</code>, <code>$vname</code>, <code>$tname</code> – names</a></h4>
<p>The name of the field, variant, or toplevel type.
This is an the identifier (without any path or generics).
For tuple fields, <code>$fname</code> is the field number.</p>
<p><code>$fname</code> is not suitable for direct use as a local variable name.
It might clash with other local variables;
and, unlike most other expansions,
<code>$fname</code> has the hygiene span of the driver field name.
Instead, use <code>$vpat</code>, <code>$fpatname</code>,
or <code>${paste ... $fname ...}</code> (<code>$&lt;... $fname ...&gt;</code>).</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<ul>
<li><code>$fname</code>: <code>0</code>, <code>field</code>, <code>field_b</code></li>
<li><code>$vname</code>: <code>UnitVariant</code></li>
<li><code>$tname</code>: <code>Tuple</code>, <code>Struct</code>, <code>Enum</code></li>
</ul>
<h4 id="fvis-tvis-fdefvis--visibility"><a href="#fvis-tvis-fdefvis--visibility"><code>$fvis</code>, <code>$tvis</code>, <code>$fdefvis</code> – visibility</a></h4>
<p>The visibility of the field, or toplevel type.</p>
<p>Expands to <code>pub</code>, <code>pub(crate)</code>, etc.
Expands to nothing for private types or fields.</p>
<p>This looks only at the syntax in the driver definition;
an item which is <code>pub</code> might still not be reachable,
for example if it is in a private inner module.</p>
<h5 id="enums-and-visibility"><a href="#enums-and-visibility">Enums and visibility</a></h5>
<p>In Rust,
enum variants and fields don’t have separate visibility;
they inherit visibility from the enum itself.
So there is no <code>$vvis</code>.</p>
<p>For enum fields, <code>$fvis</code> expands to the same as <code>$tvis</code>.
Use <code>$fvis</code> for the effective visibility of a field,
eg when defining a derived method.</p>
<p><code>$fdefvis</code> is precisely what was written in the driver field definition,
so always expands to nothing for enum fields -
even though those might be public.
Use <code>$deffvis</code> when defining a new enum.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<ul>
<li><code>$tvis</code> for <code>Unit</code>: <code>pub</code></li>
<li><code>$tvis</code> for <code>Enum</code>: <code>pub</code></li>
<li><code>$tvis</code> for others: nothing</li>
<li><code>$fvis</code> for <code>field</code> in <code>Struct</code>: <code>pub</code></li>
<li><code>$fvis</code> for <code>field_b</code> in <code>Struct</code>: <code>pub(crate)</code></li>
<li><code>$fvis</code> for fields in <code>Enum</code>: <code>pub</code></li>
<li><code>$fvis</code> for others: nothing</li>
<li><code>$fdefvis</code> for <code>field</code> in <code>Struct</code>: <code>pub</code></li>
<li><code>$fdefvis</code> for <code>field_b</code> in <code>Struct</code>: <code>pub(crate)</code></li>
<li><code>$fdefvis</code> for fields in <code>Enum</code>: nothing</li>
<li><code>$fdefvis</code> for others: nothing</li>
</ul>
<h4 id="vpat-fpatname--pattern-matching-and-value-deconstruction"><a href="#vpat-fpatname--pattern-matching-and-value-deconstruction"><code>$vpat</code>, <code>$fpatname</code> – pattern matching and value deconstruction</a></h4>
<p><code>$vpat</code> expands to a pattern
suitable for matching a value of the top-level type.
It expands to <code>TYPE { FIELD: f_FNAME, ... }</code>,
where <code>TYPE</code> names the top-level type or enum variant.
(<code>TYPE</code> doesn’t have generics,
since those are not allowed in patterns.)</p>
<p>Each field is bound to a local variant <code>f_FNAME</code>,
where <code>FNAME</code> is the actual field name (or tuple field number).</p>
<p><code>$fpatname</code> expands to <code>f_FNAME</code> for the current field.</p>
<h5 id="vpat-named-arguments"><a href="#vpat-named-arguments"><code>$vpat</code> named arguments</a></h5>
<ul>
<li><code>self</code>: top level type path.  Default is <code>$tname</code>.
Must expand to a syntactically valid type path,
without generics.</li>
<li><code>vname</code>: variant name.  Default is <code>$vname</code>.
Not expanded for structs.</li>
<li><code>fprefix</code>: prefix to use for the local bindings.
Useful if you need to bind multiple values at once.
Default is <code>f_</code>.
When using this, use pasting (<code>$&lt;FPREFIX $fname&gt;</code>)
rather than <code>$fpatname</code>.</li>
</ul>
<p>These use derive-adhoc’s usual
<a href="#named-and-positional-template-arguments-to-expansions-and-conditions">syntax for named arguments</a>.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<ul>
<li><code>$vpat</code> for structs: <code>Unit { }</code>, <code>Tuple { 0: f_0, }</code></li>
<li><code>$vpat</code> for enum variant: <code>Enum::NamedVariant { field: f_field, ... }</code></li>
<li><code>$fpatname</code>: <code>f_0</code>, <code>f_field</code></li>
<li><code>${vpat self=$&lt;$tname Reference&gt; vname=$&lt;Ref $vname&gt; fprefix=other_}</code>: <code>EnumReference::RefNamedVariant { field: other_field, ... }</code></li>
</ul>
<h4 id="ftype-vtype-ttype-tdeftype--types"><a href="#ftype-vtype-ttype-tdeftype--types"><code>$ftype</code>, <code>$vtype</code>, <code>$ttype</code>, <code>$tdeftype</code> – types</a></h4>
<p>The type of the field, variant, or the toplevel type.</p>
<p><code>$ftype</code>, <code>$vtype</code> and <code>$ttype</code>
are suitable for referencing the type in any context
(for example, when defining the type of a binding,
or as a type parameter for a generic type).
These contains all necessary generics
(as names, without any bounds etc., but within <code>::&lt;...&gt;</code>).</p>
<p><code>$vtype</code> includes both the top-level enum type, and the variant.
To construct a value, prefer <code>$vtype</code> rather than <code>$ttype</code>,
since <code>$vtype</code> works with enums too.</p>
<p><code>$tdeftype</code> is
the top-level driver type name in a form suitable for defining
a new type with a derived name (eg, using pasting).
Contains all the necessary generics, with bounds,
within <code>&lt;...&gt;</code> but without an introducing <code>::</code>.</p>
<p>The toplevel type expansions, <code>$ttype</code> and <code>$tdeftype</code>,
don’t contain a path prefix, even if
the driver type argument to
<code>derive_adhoc!</code>
had a path prefix.</p>
<p><code>$vtype</code> (and <code>$ttype</code> and <code>$tdeftype</code>) are not suitable for matching.
Use <code>$vpat</code> for that.</p>
<h5 id="vtype-named-arguments"><a href="#vtype-named-arguments"><code>$vtype</code> named arguments</a></h5>
<ul>
<li><code>self</code>: top level type.  Default is <code>$ttype</code>.
Must expand to a syntactically valid type.</li>
<li><code>vname</code>: variant name.  Default is <code>$vname</code>.
Not expanded for structs.</li>
</ul>
<p>These can be used with pasting
to name related (derived) types and variants.</p>
<p>They use derive-adhoc’s usual
<a href="#named-and-positional-template-arguments-to-expansions-and-conditions">syntax for named arguments</a>.</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<ul>
<li><code>$ftype</code>: <code>std::iter::Once::&lt;T&gt;</code></li>
<li><code>$vtype</code> for struct: <code>Tuple::&lt;'a, 'l, T, C&gt;</code></li>
<li><code>$vtype</code> for enum variant: <code>Enum::TupleVariant::&lt;'a, 'l, T, C&gt;</code></li>
<li><code>$ttype</code>: <code>Enum::&lt;'a, 'l, T, C&gt;</code></li>
<li><code>$tdeftype</code>: <code>Enum&lt;'a, 'l: 'a, T: Display = usize, const C: usize = 1&gt;</code></li>
<li><code>${vtype self=$&lt;$ttype Reference&gt; vname=$&lt;Ref $vname&gt;}</code>
for enum variant:
<code>EnumReference::RefTupleVariant::&lt;'a, 'l, T, C&gt;</code></li>
</ul>
<h4 id="tgens-tgnames-twheres-tdefgens--generics"><a href="#tgens-tgnames-twheres-tdefgens--generics"><code>$tgens</code>, <code>$tgnames</code>, <code>$twheres</code>, <code>$tdefgens</code> – generics</a></h4>
<p>Generic parameters and bounds, from the toplevel type,
in various forms.</p>
<ul>
<li>
<p><strong><code>$tgens</code></strong>:
The generic arguments, with bounds, but without defaults.
Suitable for use when starting an <code>impl</code>.</p>
</li>
<li>
<p><strong><code>$tgnames</code></strong>:
The generic argument names, without bounds.
Suitable for use in a field type or in the body of an impl.</p>
</li>
<li>
<p><strong><code>$twheres</code></strong>:
The where clauses, as written in the toplevel type definition.</p>
</li>
<li>
<p><strong><code>$tdefgens</code></strong>:
The generic arguments, with bounds, <em>with</em> defaults,
as written in the toplevel type definition,
suitable for defining a derived type.</p>
</li>
</ul>
<p>If not empty, each of these will always have a trailing comma.</p>
<p>Bounds appear in <code>$tgens</code>/<code>$tdefgens</code> or <code>$twheres</code>,
according to where they appear in the toplevel type,
so for full support of generic types the template must expand both.</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<ul>
<li><code>$tgens</code>: <code>'a, 'l: 'a, T: Display, const C: usize,</code></li>
<li><code>$tgnames</code>: <code>'a, 'l, T, C,</code></li>
<li><code>$twheres</code>: <code>T: 'l, T: TryInto&lt;u8&gt;,</code></li>
<li><code>$tdefgens</code>: <code>'a, 'l: 'a, T: Display = usize, const C: usize = 1,</code></li>
</ul>
<h4 id="tmeta-vmeta-fmeta--adhoc-attributes"><a href="#tmeta-vmeta-fmeta--adhoc-attributes"><code>${tmeta(...)}</code> <code>${vmeta(...)}</code> <code>${fmeta(...)}</code> – <code>#[adhoc]</code> attributes</a></h4>
<p>Accesses macro parameters passed via <code>#[adhoc(...)]</code> attributes.</p>
<ul>
<li>
<p><strong><code>${Xmeta(NAME)}</code></strong>:
Looks for <code>#[adhoc(NAME=&quot;VALUE&quot;)]</code>, and expands to <code>VALUE</code>.
<code>&quot;VALUE&quot;</code> must be be a string literal,
which is parsed as an arbitrary series of tokens.
<code>${Xmeta...}</code> expands to those tokens.</p>
</li>
<li>
<p><strong><code>${Xmeta(SUB(NAME))}</code></strong>:
Looks for <code>#[adhoc(SUB(NAME=&quot;VALUE&quot;))]</code>.
The <code>#[adhoc()]</code> is parsed as
a set of nested, comma-separated, lists.
So this would find <code>NAME</code> 
in <code>#[adhoc(SUB1,SUB(N1,NAME=&quot;VALUE&quot;,N2),SUB2)]</code>.
The path can be arbitrarily deep, e.g.: <code>${Xmeta(L1(L2(L3(ATTR))))}</code>.</p>
</li>
<li>
<p><strong><code>${Xmeta(...) as SYNTYPE}</code></strong>:
Treats the value as a <code>SYNTYPE</code>,
rather than an arbitrary sequence of tokens.
<code>SYNTYPE</code>s available are:</p>
<ul>
<li>
<p><strong><code>str</code></strong>: Expands to a string literal
with the same contents as
the string provided for <code>VALUE</code>.
Ie, the attribute’s string value is <em>not</em> parsed.
This is the default within pasting and case changing,
if no <code>as</code> was specified.
Within pasting and case changing,
the provided string becomes part of the pasted identifier
(and so must consist of legal identifier characters).</p>
</li>
<li>
<p><strong><code>ty</code></strong>:
<code>VALUE</code> is parsed as a type,
possibly with generics etc. (<code>syn::Type</code>).</p>
</li>
<li>
<p><strong><code>tokens</code></strong>:
<code>VALUE</code> is parsed as an arbtitrary sequence of tokens
(<code>TokenStream</code>).</p>
</li>
</ul>
</li>
</ul>
<p>When expanding <code>${Xmeta}</code>,
it is an error if the value was not specified in the driver,
and also an error if multiple values were specified.</p>
<p>For a struct, both <code>$tmeta</code> and <code>$vmeta</code>
look in the top-level attributes.
This allows a template to have uniform handling of attributes
which should affect how a set of fields should be processed.</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<ul>
<li><code>${tmeta(simple)}</code>: <code>String</code></li>
<li><code>${tmeta(simple) as ty}</code>: <code>String</code></li>
<li><code>${tmeta(simple) as str}</code>: <code>&quot;String&quot;</code></li>
<li><code>${tmeta(gentype)}</code>: <code>Vec&lt;i32&gt;</code></li>
<li><code>${tmeta(gentype) as ty}</code>: <code>Vec&lt;i32&gt;</code></li>
<li><code>${tmeta(gentype) as str}</code>: <code>&quot;Vec&lt;i32&gt;&quot;</code></li>
<li><code>${vmeta(value)}</code>: <code>unit-toplevel</code>, <code>enum-variant</code></li>
<li><code>${fmeta(nested(inner))}</code> for <code>field</code> in <code>Struct</code>: <code>42</code></li>
<li><code>${fmeta(nested)}</code>: error, <code>tried to expand attribute which is nested list</code></li>
</ul>
<h5 id="examples-involving-pasting"><a href="#examples-involving-pasting">Examples involving pasting</a></h5>
<ul>
<li><code>$&lt;Small ${tmeta(simple)}&gt;</code>: <code>SmallString</code></li>
<li><code>$&lt;Small ${tmeta(simple) as str}&gt;</code>: <code>SmallString</code></li>
<li><code>$&lt;Small ${tmeta(simple) as ty}&gt;</code>: <code>SmallString</code></li>
<li><code>$&lt;Small ${tmeta(gentype) as ty}&gt;</code>: <code>SmallVec&lt;i32&gt;</code></li>
<li><code>$&lt;$ttype ${tmeta(simple) as str}&gt;</code>: <code>UnitString::&lt;C&gt;</code></li>
<li><code>$&lt;$ttype ${tmeta(simple) as ty}&gt;</code>: error, <code>multiple nontrivial entries</code></li>
</ul>
<h4 id="fattrs--vattrs--tattrs---other-attributes"><a href="#fattrs--vattrs--tattrs---other-attributes"><code>${fattrs ...}</code> <code>${vattrs ...}</code> <code>${tattrs ...}</code> – other attributes</a></h4>
<p>Expands to attributes, including non-<code>#[adhoc()]</code> ones.
The attributes can be filtered:</p>
<ul>
<li><strong><code>$Xattrs</code></strong>: All the attributes
except <code>#[adhoc]</code> and <code>#[derive_adhoc]</code></li>
<li><strong><code>${Xattrs A1, A2, ...}</code></strong>, or
<strong><code>${Xattrs = A, A2, ...}</code></strong>:
Attributes <code>#[A1...]</code> and <code>#[A2...]</code> only.</li>
<li><strong><code>${Xattrs ! A1, A2, ...}</code></strong>:
All attributes <em>except</em> those.</li>
</ul>
<p>With <code>${Xattrs}</code>, unlike <code>${Xmeta}</code>,</p>
<ul>
<li>The expansion is the whole of each attribute, including the <code>#[...]</code>;</li>
<li>All attributes are included.</li>
<li>But <code>#[adhoc(...)]</code> and <code>#[derive_adhoc(...)]</code> are <em>excluded</em> by default,
because typically they would be rejected by the compiler:
the expanded output is (perhaps) no longer within <code>#[derive(Adhoc)]</code>,
so those attributes might be unrecognised there.</li>
<li>The attributes can be filtered by toplevel attribute name,
but not deeply manipulated.</li>
<li><code>$vattrs</code> does not, for a non-enum, include the top-level attributes .</li>
</ul>
<p>Note that derive macros,
only see attributes
that come <em>after</em> the <code>#[derive(...)]</code> that invoked them.
So derive-adhoc templates only see attributes
that come <em>after</em> the <code>#[derive(..., Adhoc, ...)]</code>.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5><h6 id="for-unit"><a href="#for-unit">For <code>Unit</code></a></h6><!--##examples-for `Unit`##-->
<ul>
<li><code>${tattrs}</code>: <code>#[derive(Clone)]</code></li>
<li><code>${tattrs ! adhoc}</code>: <code>#[derive(Clone)]</code></li>
<li><code>${tattrs missing}</code>: nothing</li>
<li><code>${tattrs derive}</code>: <code>#[derive(Clone)]</code></li>
<li><code>${vattrs adhoc}</code>: nothing</li>
</ul>
<h6 id="for-tuple"><a href="#for-tuple">For <code>Tuple</code></a></h6><!--##examples-for `Tuple`##-->
<ul>
<li><code>${tattrs}</code>: <code>#[doc=&quot; Title for `Tuple`&quot;] #[repr(C)]</code></li>
<li><code>${tattrs repr}</code>: <code>#[repr(C)]</code></li>
<li><code>${tattrs repr, adhoc}</code>: <code>#[adhoc(unused)] #[repr(C)]</code></li>
<li><code>${tattrs ! derive, doc}</code>: <code>#[adhoc(unused)] #[repr(C)] #[derive_adhoc(SomeOtherTemplate)]</code></li>
</ul>
<h6 id="for-enum"><a href="#for-enum">For <code>Enum</code></a></h6>
<ul>
<li><code>${vattrs adhoc}</code> for <code>UnitVariant</code>: <code>#[adhoc(value=&quot;enum-variant&quot;)]</code></li>
</ul>
<h4 id="-paste---identifier-pasting"><a href="#-paste---identifier-pasting"><code>$&lt;...&gt;</code>, <code>${paste ...}</code> – identifier pasting</a></h4>
<p>Expands the contents and pastes it together into a single identifier.
The contents may only contain identifer fragments, strings (<code>&quot;...&quot;</code>),
and (certain) expansions.
Supported expansions are <code>$ftype</code>, <code>$ttype</code>, <code>$tdeftype</code>, <code>$Xname</code>,
<code>${Xmeta as ty}</code>, <code>${Xmeta as str}</code>,
<code>$&lt;...&gt;</code>,
<code>${paste ...}</code>,
<code>${CASE_CHANGE ...}</code>,
<code>$tdefkwd</code>,
as well as conditionals and repetitions.</p>
<p>The contents can contain at most one occurrence of
a more complex type expansion <code>${Xtype}</code>
(or <code>${Xmeta as ty)</code>),
which must refer to a path (perhaps with generics).
Then the pasting will be applied to the final path element identifier,
and the path prefix and generics reproduced unaltered.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<ul>
<li><code>$&lt;Zingy $ftype Builder&gt;</code> for <code>TupleVariant</code>:
<code>std::iter::ZingyOnceBuilder::&lt;T&gt;</code></li>
<li><code>${paste x_ $fname}</code> for tuple: <code>x_0</code></li>
<li><code>${paste $fname _x}</code> for tuple: error, <code>constructed identifier &quot;0_x&quot; is invalid</code></li>
</ul>
<h4 id="case_change---case-changing"><a href="#case_change---case-changing"><code>${CASE_CHANGE ...}</code> – case changing</a></h4>
<p>Expands the content, and changes its case
(eg. uppercase to lowercase, etc.
See <a href="#case-changing">Case changing</a>.
<code>CASE_CHANGE</code> is one of the values listed there.</p>
<h4 id="when-condition--filtering-out-repetitions-by-a-predicate"><a href="#when-condition--filtering-out-repetitions-by-a-predicate"><code>${when CONDITION}</code> – filtering out repetitions by a predicate</a></h4>
<p>Allowed only within repetitions, and only at the toplevel
of the repetition,
before other expansions.
Skips this repetition if the <code>CONDITION</code> is not true.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<ul>
<li><code>$( ${when vmeta(value)} ${vmeta(value) as str} )</code> for <code>Enum</code>: <code>&quot;enum-variant&quot;</code></li>
</ul>
<h4 id="if-cond1----else-if-cond2----else-----conditional"><a href="#if-cond1----else-if-cond2----else-----conditional"><code>${if COND1 { ... } else if COND2 { ... } else { ... }}</code> – conditional</a></h4>
<p>Conditionals.  The else clause is, of course, optional.
The <code>else if</code> between arms is also optional,
but <code>else</code> in the fallback clause is mandatory.
So you can write <code>${if COND1 { ... } COND2 { ... } else { ... }</code>.</p>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5>
<ul>
<li><code>${if is_enum { E } is_struct { S }}</code> for <code>Enum</code>: <code>E</code></li>
<li><code>${if is_enum { E } is_struct { S }}</code> for others: <code>S</code></li>
<li><code>$( ${if v_is_named { N } v_is_tuple { T }} )</code> for <code>Enum</code>: <code>T N</code></li>
<li><code>$( ${if v_is_named { N } v_is_tuple { T } else { X }} )</code> for <code>Enum</code>: <code>X T N</code></li>
<li><code>${if v_is_unit { U } tmeta(gentype) { GT }}</code> for <code>Unit</code>: <code>U</code></li>
</ul>
<h4 id="select1-cond1----else-if-cond2----else-----expect-precisely-one-predicate"><a href="#select1-cond1----else-if-cond2----else-----expect-precisely-one-predicate"><code>${select1 COND1 { ... } else if COND2 { ... } else { ... }}</code> – expect precisely one predicate</a></h4>
<p>Conditionals which insist on expanding exactly one of the branches.
Syntax is identical to that of <code>${if }</code>.
<em>All</em> of the <code>COND</code> are always evaluated.
Exactly one of them must be true;
or, none of them, but only if an <code>else</code> is supplied -
otherwise it is an error.</p>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<ul>
<li><code>${select1 is_enum { E } is_struct { S }}</code>: <code>E</code>, <code>S</code></li>
<li><code>${select1 v_is_named { N } v_is_tuple { T }}</code> for <code>Enum</code>: error, <code>no conditions matched, and no else clause</code></li>
<li><code>$( ${select1 v_is_named { N } v_is_tuple { T } else { X }} )</code> for <code>Enum</code>: <code>X T N</code></li>
<li><code>${select1 v_is_unit { U } tmeta(gentype) { GT }}</code> for <code>Unit</code>: error, <code>multiple conditions matched</code></li>
</ul>
<h4 id="for-fields----for-variants-------repetition"><a href="#for-fields----for-variants-------repetition"><code>${for fields { ... }}</code>, <code>${for variants { ... }}</code>, <code>$( )</code> – repetition</a></h4>
<p><code>${for ...}</code> expands the contents once per field, or once per variant.</p>
<p><code>$( ... )</code> expands the input with an appropriate number of iterations -
see <a href="#repetition-and-nesting">Repetition and nesting</a>.</p>
<h4 id="crate--root-of-template-crate"><a href="#crate--root-of-template-crate"><code>$crate</code> – root of template crate</a></h4>
<p><code>$crate</code> always refers to the root of the crate 
defining the template.
Within a <code>pub</code> template,
being expanded in another crate,
it refers to the crate containing the template definition.
In templates being used locally,
it refers to the current crate, ie simply <code>crate</code>.</p>
<p>This is similar to the <code>$crate</code> builtin expansion
in <code>macro_rules!</code>.</p>
<h4 id="tdefkwd--keyword-introducing-the-new-data-structure"><a href="#tdefkwd--keyword-introducing-the-new-data-structure"><code>$tdefkwd</code> – keyword introducing the new data structure</a></h4>
<p>Expands to <code>struct</code>, <code>enum</code>, or <code>union</code>.</p>
<h4 id="tdefvariants-vdefbody-fdefine--tools-for-defining-types"><a href="#tdefvariants-vdefbody-fdefine--tools-for-defining-types"><code>$tdefvariants</code>, <code>$vdefbody</code>, <code>$fdefine</code> – tools for defining types</a></h4>
<p>These, used together, allow the template to expand to a
new definition, mirroring the driver type in form.</p>
<p><strong><code>${tdefvariants VARIANTS}</code></strong> expands to <code>{ VARIANTS }</code> for an enum,
or just <code>VARIANTS</code> otherwise.
Usually, it would contain a <code>$( )</code> repeating over the variants,
expanding <code>$vdefbody</code> for each one.</p>
<p><strong><code>${fdefine FNAME}</code></strong> expands to <code>FNAME:</code> in the context of
named fields (a “struct” or “struct variant”),
or nothing otherwise.</p>
<p><strong><code>${vdefbody VNAME FIELDS}</code></strong> expands to the definition of a variant,
with a appropriate delimiters.
Usualy, it would contain a <code>$( )</code> repeating over the fields,
using <code>$fdefine</code> to introduce each one.
Specifically:</p>
<!--##examples-possibilities-blockquote##-->
<!--iiiiiiiiiiiiiiiiiiiiiii fffffffffffffffffffff oooooooooooooooooo ###############-->
<div class="example-wrap"><pre class="language-text"><code> ${vdefbody VNAME FIELDS}   for unit                FIELDS;          [*] ie  ;
 ${vdefbody VNAME FIELDS}   for tuple             ( FIELDS );
 ${vdefbody VNAME FIELDS}   for braced struct     { FIELDS }
 ${vdefbody VNAME FIELDS}   for unit variant      VNAME   FIELDS,    [*] ie  VNAME,
 ${vdefbody VNAME FIELDS}   for tuple variant     VNAME ( FIELDS ),
 ${vdefbody VNAME FIELDS}   for braced variant    VNAME { FIELDS }
</code></pre></div>
<p><code>[*]</code>: In the unit and unit variant cases,
<code>FIELDS</code> ought to expand to nothing;
otherwise, the expansion of <code>$vdefbody</code>
will probably be syntactically invalid in context.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5><div class="example-wrap"><pre class="language-text"><code>$tvis $tdefkwd $&lt;$tname Copy&gt;&lt;$tdefgens&gt;
${tdefvariants $(
    ${vdefbody $&lt;$vname Copy&gt; $(
        $fdefvis ${fdefine $&lt;$fname _copy&gt;} $ftype,
    ) }
) }
</code></pre></div><!--##examples-for-toplevels-concat Tuple Enum##-->
<p>Expands to (when applied to <code>Tuple</code> and <code>Enum</code>):</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>TupleCopy&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;l</span>: <span class="lifetime">&#39;a</span>, T: Display = usize, <span class="kw">const </span>C: usize = <span class="number">1</span>,&gt;(
    <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">&amp;</span><span class="lifetime">&#39;l </span>T,
);
<span class="kw">pub enum </span>EnumCopy&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;l</span>: <span class="lifetime">&#39;a</span>, T: Display = usize, <span class="kw">const </span>C: usize = <span class="number">1</span>,&gt; {
    UnitVariantCopy,
    TupleVariantCopy(std::iter::Once::&lt;T&gt;,),
    NamedVariantCopy { field_copy: <span class="kw-2">&amp;</span><span class="lifetime">&#39;l </span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>T, ... }
}</code></pre></div>
<h4 id="dbg_all_keywords--dump-expansions-of-all-keywords-to-compiler-stderr"><a href="#dbg_all_keywords--dump-expansions-of-all-keywords-to-compiler-stderr"><code>$dbg_all_keywords</code> – Dump expansions of all keywords to compiler stderr</a></h4>
<p>Prints a listing of all the available expansion keywords,
and conditions,
along with their expansions and values.
(The output goes to the compiler’s stderr;
the actual expansion is empty.)</p>
<p>This can be helpful to see which expansion keywords
might be useful for a particular task.
(Before making a final selection of keyword
you probably want to refer to this reference manual.)</p>
<p>You will not want to leave this option in production code,
as it makes builds noisy.</p>
<p>See also the <a href="#dbg--print-the-expansion-to-stderr-for-debugging"><code>dbg</code> expansion option</a>.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Adhoc)]
</span><span class="kw">enum </span>Enum {
    Unit,
    Tuple(usize),
    Struct { field: String },
}
<span class="macro">derive_adhoc! </span>{
    Enum:
    <span class="macro-nonterminal">$dbg_all_keywords
    </span><span class="comment">// ... rest of the template you&#39;re developing ...
</span>}</code></pre></div>
<h4 id="define--defcond---user-defined-expansions-and-conditions"><a href="#define--defcond---user-defined-expansions-and-conditions"><code>${define ...}</code>, <code>${defcond ...}</code> – user-defined expansions and conditions</a></h4>
<p><code>${define NAME BODY}</code> defines a reuseable piece of template.
Afterwards, <code>$NAME</code> (and <code>${NAME}</code>) expand <code>BODY</code>.</p>
<p><code>${defcond NAME CONDITION}</code> defines a reuseable condition.
Afterwards, the name <code>NAME</code> can be used as a condition -
evaluating <code>CONDITION</code>.</p>
<p><code>NAME</code> is an identifier.
It may not start with a lowercase letter or underscore:
those expansion names are reserved for
derive-adhoc’s built-in functionality.</p>
<p><code>BODY</code> is in the
<a href="#named-and-positional-template-arguments-to-expansions-and-conditions">standard syntax for positional arguments</a>.</p>
<p><code>CONDITION</code> is in the standard syntax for a condition.</p>
<p><code>NAME</code> is visible after its definition in the same template or group,
including in inner templates and groups.
Definitions may be re-defined by inner scopes.
Scope is dynamic,
both for derive-adhoc built-ins and user definitions:
<code>BODY</code> and <code>CONDITION</code> are captured
without expansion/evaluation at the site of <code>$define</code>/<code>$defcond</code>,
and the contents expanded/evaluated
each time according
to the values and definitions prevailing
in the dynamic context where <code>NAME</code> is used.</p>
<p><code>${NAME}</code> may only be used
inside pasting and case changing
if <code>BODY</code> was precisely an invocation of <code>${paste }</code> or <code>$&lt;...&gt;</code>.</p>
<p>You can define an expansion and a condition with the same name;
they won’t interfere.</p>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<ul>
<li><code>${define VN $vname} ${for variants { $VN }}</code>:
<code>UnitVariant TupleVariant NamedVariant</code></li>
<li><code>${define FN $&lt;$fname _&gt;} $&lt;${for fields { &quot;F&quot; $FN }}&gt;</code>:
<code>F0_</code>, <code>Ffield_Ffield_b_</code></li>
</ul>
<h6 id="example-including-a-condition"><a href="#example-including-a-condition">Example including a condition</a></h6>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>${define T_FIELDS ${paste <span class="macro-nonterminal">$tname </span>Fields}}
${defcond F_ENABLE all(fvis, v_is_named)}
<span class="macro-nonterminal">$tvis </span><span class="kw">struct </span><span class="macro-nonterminal">$T_FIELDS </span>{ $(
    ${when F_ENABLE} <span class="macro-nonterminal">$fvis $fname</span>: bool,
) }
<span class="macro-nonterminal">$tvis </span><span class="kw">const </span>${shouty_snake_case ALL_ <span class="macro-nonterminal">$T_FIELDS</span>}: <span class="macro-nonterminal">$T_FIELDS </span>= { $(
    ${when F_ENABLE} <span class="macro-nonterminal">$fname</span>: <span class="bool-val">true</span>,
) };</code></pre></div>
<!--##examples-for-toplevels-concat Unit Tuple Struct##-->
<p>Expands to (for <code>Unit</code>, <code>Tuple</code> and <code>Struct</code>):</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">pub struct </span>UnitFields {}
<span class="kw">pub const </span>ALL_UNIT_FIELDS: UnitFields = {};
<span class="kw">struct </span>TupleFields {}
<span class="kw">const </span>ALL_TUPLE_FIELDS: TupleFields = {};
<span class="kw">struct </span>StructFields {
    <span class="kw">pub </span>field: bool,
}
<span class="kw">const </span>ALL_STRUCT_FIELDS: StructFields = {
    field: <span class="bool-val">true</span>,
};</code></pre></div>
<h3 id="conditions"><a href="#conditions">Conditions</a></h3>
<p>Conditions all start with a <code>KEYWORD</code>.
They are found within <code>${if }</code>, <code>${when }</code>, and <code>${select1 }</code>.</p>
<!-- ## maint/check-keywords-documented conditions ## -->
<h4 id="fvis-tvis-fdefvis--test-for-public-visibility"><a href="#fvis-tvis-fdefvis--test-for-public-visibility"><code>fvis</code>, <code>tvis</code>, <code>fdefvis</code> – test for public visibility</a></h4>
<p>True iff the field, or the whole toplevel type, is <code>pub</code>.</p>
<p>See
<a href="#fvis-tvis-fdefvis--visibility"><code>$fvis</code>, <code>$tvis</code> and <code>$fdefvis</code></a>
for details of the semantics (especially for enums),
and the difference between <code>$fvis</code> and <code>$fdefvis</code>.</p>
<p>Within-crate visibility, e.g. <code>pub(crate)</code>, is treated as “not visible”
for the purposes of <code>fvis</code> and <code>tvis</code>
(although the <code>$fvis</code> and <code>$tvis</code> expansions will handle those faithfully).</p>
<h5 id="examples-11"><a href="#examples-11">Examples</a></h5>
<ul>
<li><code>tvis</code>: true for <code>Unit</code>, and <code>Enum</code></li>
<li><code>fvis</code>: true for <code>field</code> in <code>Struct</code>, and fields in <code>Enum</code></li>
<li><code>fdefvis</code>: true for <code>field</code> in <code>Struct</code></li>
</ul>
<!--##examples-ignore##-->
<p>And in each case, false for all others.
(Refer to the <a href="#structs-used-in-examples">example structs</a>, below.)</p>
<h4 id="fmetaname-vmetaname-tmetaname--adhoc-attributes"><a href="#fmetaname-vmetaname-tmetaname--adhoc-attributes"><code>fmeta(NAME)</code>, <code>vmeta(NAME)</code>, <code>tmeta(NAME)</code> – <code>#[adhoc]</code> attributes</a></h4>
<p>Looks for <code>#[adhoc(NAME)]</code>.</p>
<p>True iff there was such an attribute.
<code>Xmeta(SUB(NAME))</code> works, just as with the <code>${Xmeta ...}</code> expansion.</p>
<p>The condition is true if there is at least one matching entry,
and (unlike <code>${Xmeta}</code>)
the corresponding driver attribute does not need to be a <code>=LIT</code>.</p>
<p>So <code>Xmeta(SUB(NAME))</code> is true if the driver has
<code>#[adhoc(SUB(NAME(INNER=...)))]</code> or <code>#[adhoc(SUB(NAME))]</code> or
<code>#[adhoc(SUB(NAME=LIT))]</code> or even <code>#[adhoc(SUB(NAME()))]</code>.</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<ul>
<li><code>tmeta(unused)</code>: true for <code>Tuple</code></li>
<li><code>tmeta(gentype)</code>: true for <code>Unit</code></li>
<li><code>vmeta(value)</code>: true for <code>Unit</code>, and <code>Enum::UnitVariant</code></li>
<li><code>fmeta(nested)</code>: true for <code>field</code> in <code>Struct</code></li>
</ul>
<h4 id="is_struct-is_enum-is_union"><a href="#is_struct-is_enum-is_union"><code>is_struct</code>, <code>is_enum</code>, <code>is_union</code></a></h4>
<p>The driver data structure is a struct, enum, or union, respectively.</p>
<p>Prefer to avoid these explicit tests,
when writing a template to work with either structs or enums.
Instead,
use <code>match</code> and <code>$vpat</code> for deconstructing values,
and <code>$vtype</code> for constructing them.
Use <code>$tdefvariants</code> when defining a derived type.</p>
<h4 id="v_is_unit-v_is_tuple-v_is_named"><a href="#v_is_unit-v_is_tuple-v_is_named"><code>v_is_unit</code>, <code>v_is_tuple</code>, <code>v_is_named</code></a></h4>
<p>Whether and what kind of fields there are.</p>
<p>Prefer to avoid these explicit tests,
when writing a template to work with any shape of structure.
Instead,
use Rust’s universal <code>Typename { }</code> syntax,
possibly via <code>$vpat</code> and <code>$fpatname</code>,
or via <code>$vtype</code>.
The <code>Typename { }</code> syntax can be used for matching and constructing
all kinds of structures, including units and tuples.
Use <code>$vdefbody</code> and <code>$fdefine</code> when defining a derived type.</p>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<ul>
<li><code>v_is_unit</code>: true for <code>struct Unit;</code>, and <code>Enum::UnitVariant;</code></li>
<li><code>v_is_tuple</code>: true for <code>struct Tuple(...);</code>, and <code>Enum::TupleVariant(...);</code></li>
<li><code>v_is_named</code>: true for <code>struct Struct {...}</code>, and <code>Enum::NamedVariant {...}</code></li>
</ul>
<h4 id="approx_equalarg1-arg2--equality-comparison-token-comparison"><a href="#approx_equalarg1-arg2--equality-comparison-token-comparison"><code>approx_equal(ARG1, ARG2)</code> – equality comparison (token comparison)</a></h4>
<p>The two <code>ARGS</code>s are each expanded (as series of tokens)
and compared for equality.</p>
<p>Span is disregarded, so
two identifiers that would refer to different types or values,
but which have the same name,
would count as equal.</p>
<p>Spacing is disregarded, even between punctuation characters.
For example, <code>approx_equal</code> regards <code>&lt;&lt;</code> as equal to <code>&lt; &lt;</code>.
This means expansions might count as equal
even if the Rust compiler would accept one and reject the other;
and, expansions migtht count as equal
even if macros could tell the difference.</p>
<p>If both inputs are valid Rust types,
they will only compare equal if they are syntactically the same.
(Note that different ways of writing the same type
are treated as different:
for example, <code>Vec&lt;u8&gt;</code> is not equal to <code>Vec&lt;u8, Global&gt;</code>
and <code>std::os::raw::c_char</code> is not equal to <code>std::ffi::c_char</code>.)</p>
<p>The <code>ARG</code>s are in derive-adhoc’s usual
<a href="#named-and-positional-template-arguments-to-expansions-and-conditions">syntax for positional arguments</a>.</p>
<h4 id="false-true-notcondition-anycond1cond2-allcond1cond2--boolean-logic"><a href="#false-true-notcondition-anycond1cond2-allcond1cond2--boolean-logic"><code>false</code>, <code>true</code>, <code>not(CONDITION)</code>, <code>any(COND1,COND2,...)</code>, <code>all(COND1,COND2,...)</code> – boolean logic</a></h4><h3 id="case-changing"><a href="#case-changing">Case changing</a></h3>
<p><code>${CASE_CHANGE ...}</code> makes an identifier
with a different case to the input which produces it.
This is useful to make identifiers with the natural spelling
for their kind,
out of identifiers originally for something else.</p>
<p>If the content’s expansion is a path, only the final segment is changed.</p>
<p>The content must be valid within <code>${paste }</code>,
and is treated the same way.
<code>${CASE_CHANGE }</code> may appear within pasting and vice versa.</p>
<p>This table shows the supported case styles.
Note that changing the case can add and remove underscores.
The precise details are as for <a href="../../heck/index.html" title="mod heck"><code>heck</code></a>,
which is used to implement the actual case changing.</p>
<!-- ## maint/check-keywords-documented cases ## -->
<div><table><thead><tr><th><code>CASE_CHANGE</code></th><th><code>CASE_CHANGE</code> aliases</th><th>Name in <a href="../../heck/index.html" title="mod heck"><code>heck</code></a></th><th>Example of results</th></tr></thead><tbody>
<tr><td><code>pascal_case</code></td><td><code>upper_camel_case</code></td><td><code>UpperCamelCase</code></td><td><code>PascalCase</code></td></tr>
<tr><td><code>snake_case</code></td><td></td><td><code>SnakeCase</code></td><td><code>snake_case</code></td></tr>
<tr><td><code>shouty_snake_case</code></td><td></td><td><code>ShoutySnakeCase</code></td><td><code>SHOUTY_SNAKE_CASE</code></td></tr>
<tr><td><code>lower_camel_case</code></td><td></td><td><code>LowerCamelCase</code></td><td><code>lowerCamelCase</code></td></tr>
</tbody></table>
</div><h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<ul>
<li><code>${shouty_snake_case $ttype}</code>: <code>ENUM::&lt;'a, 'l, T, C&gt;</code></li>
<li><code>${pascal_case $fname}</code>: <code>Field</code>, <code>FieldB</code></li>
<li><code>${pascal_case x_ $fname _y}</code>: <code>XFieldBY</code></li>
<li><code>$&lt;x_ ${lower_camel_case $fname} _y&gt;</code>: <code>x_fieldB_y</code></li>
<li><code>${lower_camel_case $fname}</code> for tuple: error, <code>constructed identifier &quot;0&quot; is invalid</code></li>
</ul>
<h3 id="expansion-options"><a href="#expansion-options">Expansion options</a></h3>
<p>You can pass options,
which will be applied to each relevant template expansion:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// Expand TEMPLATE for DataStructureType, with OPTIONS
</span><span class="macro">derive_adhoc! </span>{ DataStructureType OPTIONS,... : TEMPLATE }

<span class="comment">// Define a template Template which always expands with OPTIONS
</span><span class="macro">define_derive_adhoc! </span>{ Template OPTIONS,... = TEMPLATE }

<span class="comment">// Expand Template for DataStructureType, with OPTIONS
</span><span class="attr">#[derive(Adhoc)]
#[derive_adhoc(Template[OPTIONS,...]</span>)]
<span class="kw">struct </span>DataStructureType {</code></pre></div>
<p>Multiple options, perhaps specified in different places,
may apply to a single expansion.
Even multiple occurrences of the same option are fine,
so long as they don’t contradict each other.</p>
<p>The following expansion options are recognised:</p>
<h4 id="expect-items-expect-expr--syntax-check-the-expansion"><a href="#expect-items-expect-expr--syntax-check-the-expansion"><code>expect items</code>, <code>expect expr</code> – syntax check the expansion</a></h4>
<p>Syntax checks the expansion,
checking that it can be parsed as items, or as an expression.</p>
<p>If not, it is an error.
Also, then, an attempt is made to produce
compiler error message(s) pointing to the syntax error
<em>in a copy of the template expansion</em>,
as well as reporting the error at
the part of the template or driver which generated
that part of the expansiuon.</p>
<p>This is useful for debugging.</p>
<h4 id="for-struct-for-enum-for-union--insist-on-a-particular-driver-kind"><a href="#for-struct-for-enum-for-union--insist-on-a-particular-driver-kind"><code>for struct</code>, <code>for enum</code>, <code>for union</code> – Insist on a particular driver kind</a></h4>
<p>Checks the driver data structure kind
against the <code>for</code> option value.
If it doesn’t match, it is an error.</p>
<p>This is useful to produce good error messages:
Normally, derive-adhoc does not explicitly check the driver kind,
and simply makes it available to the template via expansion variables.
But, often,
a template is written only with a particular driver kind in mind,
and otherwise produces syntactically invalid output
leading to confusing compiler errors.</p>
<p>This option is only allowed in a template,
not in a driver’s <code>#[derive_adhoc]</code> attribute.</p>
<h4 id="dbg--print-the-expansion-to-stderr-for-debugging"><a href="#dbg--print-the-expansion-to-stderr-for-debugging"><code>dbg</code> – Print the expansion to stderr, for debugging</a></h4>
<p>Prints the template’s expansion to stderr, during compilation,
for debugging purposes.</p>
<p>You will not want to leave this option in production code,
as it makes builds noisy.</p>
<p>See also the <a href="#dbg_all_keywords--dump-expansions-of-all-keywords-to-compiler-stderr"><code>$dbg_all_keywords</code> expansion</a>.</p>
<h4 id="expansion-options-example"><a href="#expansion-options-example">Expansion options example</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">define_derive_adhoc! </span>{ Nothing <span class="kw">for struct</span>, expect items = }

<span class="attr">#[derive(Adhoc)]
#[derive_adhoc(Nothing[expect items, dbg]</span>)]
<span class="kw">struct </span>Unit;</code></pre></div>
<p>This defines a reuseable template <code>Nothing</code>
which can be applied only to structs,
and whose output is syntax checked as item(s).
(The template’s actual expansion is empty,
so it does indeed expand to zero items.)</p>
<p>Then it applies that to template to <code>struct Unit</code>,
restating the requirement that the expansion should be item(s).
and dumping the expansion to stderr during compilation.</p>
<h3 id="structs-used-in-examples"><a href="#structs-used-in-examples">Structs used in examples</a></h3>
<p>The example expansions in the syntax reference 
are those generated for the following driver types:</p>
<!--##examples-structs##-->

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Adhoc)]
#[derive(Clone)]
#[adhoc(simple=<span class="string">&quot;String&quot;</span>, gentype=<span class="string">&quot;Vec&lt;i32&gt;&quot;</span>)]
#[adhoc(value=<span class="string">&quot;unit-toplevel&quot;</span>)]
</span><span class="kw">pub struct </span>Unit&lt;<span class="kw">const </span>C: usize = <span class="number">1</span>&gt;;

<span class="attr">#[derive(Adhoc, Clone)]
</span><span class="doccomment">/// Title for `Tuple`
</span><span class="attr">#[adhoc(unused)]
#[repr(C)]
#[derive_adhoc(SomeOtherTemplate)]
</span><span class="kw">struct </span>Tuple&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;l</span>: <span class="lifetime">&#39;a</span>, T: Display = usize, <span class="kw">const </span>C: usize = <span class="number">1</span>&gt;(
    <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">&amp;</span><span class="lifetime">&#39;l </span>T,
);

<span class="attr">#[derive(Adhoc)]
</span><span class="kw">struct </span>Struct&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;l</span>: <span class="lifetime">&#39;a</span>, T: Display = usize, <span class="kw">const </span>C: usize = <span class="number">1</span>&gt;
<span class="kw">where </span>T: <span class="lifetime">&#39;l</span>, T: TryInto&lt;u8&gt;
{
    <span class="attr">#[adhoc(nested(inner = <span class="string">&quot;42&quot;</span>))]
    </span><span class="kw">pub </span>field: <span class="kw-2">&amp;</span><span class="lifetime">&#39;l </span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>T,
    <span class="kw">pub</span>(<span class="kw">crate</span>) field_b: String,
}

<span class="attr">#[derive(Adhoc)]
</span><span class="kw">pub enum </span>Enum&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;l</span>: <span class="lifetime">&#39;a</span>, T: Display = usize, <span class="kw">const </span>C: usize = <span class="number">1</span>&gt;
<span class="kw">where </span>T: <span class="lifetime">&#39;l</span>, T: TryInto&lt;u8&gt;
{
    <span class="attr">#[adhoc(value=<span class="string">&quot;enum-variant&quot;</span>)]
    </span>UnitVariant,
    TupleVariant(std::iter::Once::&lt;T&gt;),
    NamedVariant { 
        field: <span class="kw-2">&amp;</span><span class="lifetime">&#39;l </span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>T,
        field_b: String,
        field_e: &lt;T <span class="kw">as </span>TryInto&lt;u8&gt;&gt;::Error,
     },
}</code></pre></div>
</div></details></section></div></main></body></html>